package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// TestCase represents a generated test case
type TestCase struct {
	Name       string
	InputFile  string
	OutputFile string
	Format     string
}

func main() {
	testDataDir := "testdata"
	outputFile := "hbt_test.go"

	// Find all test cases
	testCases, err := findTestCases(testDataDir)
	if err != nil {
		log.Fatalf("Error finding test cases: %v", err)
	}

	// Generate test file
	if err := generateTestFile(outputFile, testCases); err != nil {
		log.Fatalf("Error generating test file: %v", err)
	}

	fmt.Printf("Generated %d test cases in %s\n", len(testCases), outputFile)
}

func findTestCases(testDataDir string) ([]TestCase, error) {
	var testCases []TestCase

	// Map to track input files by their stem (name without .input.ext)
	inputFiles := make(map[string]string)
	expectedFiles := make(map[string]map[string]string) // stem -> format -> file

	err := filepath.WalkDir(testDataDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || d.Name() == "collection.schema.json" {
			return nil
		}

		fileName := d.Name()

		// Check for input files
		if stem, found := stripInputSuffix(fileName); found {
			inputFiles[stem] = path
		}

		// Check for expected output files
		if stem, format, found := stripExpectedSuffix(fileName); found {
			if expectedFiles[stem] == nil {
				expectedFiles[stem] = make(map[string]string)
			}
			expectedFiles[stem][format] = path
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Generate test cases by matching input and expected files
	for stem, inputPath := range inputFiles {
		if outputs, exists := expectedFiles[stem]; exists {
			for format, expectedPath := range outputs {
				// Create test name based on path and format
				category := filepath.Base(filepath.Dir(inputPath))
				testName := generateTestName(category, stem, format)

				testCases = append(testCases, TestCase{
					Name:       testName,
					InputFile:  inputPath,
					OutputFile: expectedPath,
					Format:     format,
				})
			}
		}
	}

	return testCases, nil
}

// stripInputSuffix removes input suffixes and returns the stem
func stripInputSuffix(fileName string) (string, bool) {
	suffixes := []string{".input.html", ".input.md", ".input.json", ".input.xml"}
	for _, suffix := range suffixes {
		if strings.HasSuffix(fileName, suffix) {
			return strings.TrimSuffix(fileName, suffix), true
		}
	}
	return "", false
}

// stripExpectedSuffix removes expected suffixes and returns stem and format
func stripExpectedSuffix(fileName string) (string, string, bool) {
	suffixes := map[string]string{
		".expected.yaml": "yaml",
		".expected.html": "html",
	}

	for suffix, format := range suffixes {
		if strings.HasSuffix(fileName, suffix) {
			stem := strings.TrimSuffix(fileName, suffix)
			return stem, format, true
		}
	}
	return "", "", false
}

// generateTestName creates a valid Go test function name
func generateTestName(category, stem, format string) string {
	// Convert to PascalCase and make it a valid Go identifier
	parts := []string{"Test"}

	caser := cases.Title(language.AmericanEnglish)

	if category != "" {
		parts = append(parts, caser.String(category))
	}

	if stem != "" {
		// Replace non-alphanumeric characters with underscores and title case each part
		stemParts := strings.FieldsFunc(stem, func(r rune) bool {
			return !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9'))
		})

		for _, part := range stemParts {
			if part != "" {
				parts = append(parts, caser.String(part))
			}
		}
	}

	if format == "html" {
		parts = append(parts, "Html")
	} else {
		parts = append(parts, caser.String(format))
	}

	return strings.Join(parts, "")
}

func generateTestFile(outputFile string, testCases []TestCase) error {
	const testTemplate = `// Code generated by testgen

package main

import (
	"testing"

	"github.com/henrytill/hbt-go/internal"
)
{{range .TestCases}}
func {{.Name}}(t *testing.T) {
	internal.RunHbtAndCompare(t, {{printf "%q" .Format}}, {{printf "%q" .InputFile}}, {{printf "%q" .OutputFile}})
}
{{end}}
`

	templateData := struct {
		TestCases []TestCase
	}{
		TestCases: testCases,
	}

	// Parse and execute template
	tmpl, err := template.New("test").Parse(testTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse test template: %w", err)
	}

	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, templateData)
}
