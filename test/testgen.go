//go:build ignore

package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type TestCase struct {
	Name       string
	InputFile  string
	OutputFile string
	Format     string
}

var caser = cases.Title(language.AmericanEnglish)

func stripInputSuffix(fileName string) (string, bool) {
	suffixes := []string{".input.html", ".input.md", ".input.json", ".input.xml"}

	for _, suffix := range suffixes {
		if strings.HasSuffix(fileName, suffix) {
			stem := strings.TrimSuffix(fileName, suffix)
			return stem, true
		}
	}
	return "", false
}

func stripExpectedSuffix(fileName string) (string, string, bool) {
	suffixes := map[string]string{
		".expected.yaml": "yaml",
		".expected.html": "html",
	}

	for suffix, format := range suffixes {
		if strings.HasSuffix(fileName, suffix) {
			stem := strings.TrimSuffix(fileName, suffix)
			return stem, format, true
		}
	}
	return "", "", false
}

func findTestCases(testDataDir string) ([]TestCase, error) {
	var testCases []TestCase

	inputFiles := make(map[string]string)
	expectedFiles := make(map[string]map[string]string)

	err := filepath.WalkDir(testDataDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || d.Name() == "collection.schema.json" {
			return nil
		}

		fileName := d.Name()
		relPath, err := filepath.Rel(testDataDir, path)
		if err != nil {
			return err
		}
		relDir := filepath.Dir(relPath)

		if fileStem, found := stripInputSuffix(fileName); found {
			fullStem := filepath.Join(relDir, fileStem)
			inputFiles[fullStem] = path
		}

		if fileStem, format, found := stripExpectedSuffix(fileName); found {
			fullStem := filepath.Join(relDir, fileStem)
			if expectedFiles[fullStem] == nil {
				expectedFiles[fullStem] = make(map[string]string)
			}
			expectedFiles[fullStem][format] = path
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	for fullStem, inputPath := range inputFiles {
		if outputs, exists := expectedFiles[fullStem]; exists {
			for format, expectedPath := range outputs {
				category := filepath.Base(filepath.Dir(fullStem))
				fileStem := filepath.Base(fullStem)
				testName := generateTestName(category, fileStem, format)

				testCases = append(testCases, TestCase{
					Name:       testName,
					InputFile:  inputPath,
					OutputFile: expectedPath,
					Format:     format,
				})
			}
		}
	}

	sort.Slice(testCases, func(i, j int) bool {
		return testCases[i].Name < testCases[j].Name
	})

	return testCases, nil
}

func titleCase(s string) string {
	lower := strings.ToLower(s)
	switch lower {
	case "html":
		return "HTML"
	case "xml":
		return "XML"
	case "json":
		return "JSON"
	case "yaml":
		return "YAML"
	case "url":
		return "URL"
	default:
		return caser.String(s)
	}
}

func splitIntoAlphanumericParts(s string) []string {
	return strings.FieldsFunc(s, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsDigit(r)
	})
}

func generateTestName(category, stem, format string) string {
	parts := []string{"Test"}

	if category != "" {
		parts = append(parts, titleCase(category))
	}

	if stem != "" {
		stemParts := splitIntoAlphanumericParts(stem)
		for _, part := range stemParts {
			if part != "" {
				parts = append(parts, titleCase(part))
			}
		}
	}

	parts = append(parts, titleCase(format))

	return strings.Join(parts, "")
}

func generateTestFile(outputFile string, testCases []TestCase) error {
	const testTemplate = `// Begin code generated by testgen

package test

//go:generate go run testgen.go

import (
	"testing"
)
{{range .TestCases}}
func {{.Name}}(t *testing.T) {
	RunHbtAndCompare(t, {{printf "%q" .Format}}, {{printf "%q" .InputFile}}, {{printf "%q" .OutputFile}})
}
{{end}}
// End
`

	templateData := struct {
		TestCases []TestCase
	}{
		TestCases: testCases,
	}

	tmpl, err := template.New("test").Parse(testTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse test template: %w", err)
	}

	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, templateData)
}

func main() {
	testDataDir := "testdata"
	outputFile := "cli_test.go"

	testCases, err := findTestCases(testDataDir)
	if err != nil {
		log.Fatalf("Error finding test cases: %v", err)
	}

	if err := generateTestFile(outputFile, testCases); err != nil {
		log.Fatalf("Error generating test file: %v", err)
	}

	fmt.Printf("Generated %d test cases in %s\n", len(testCases), outputFile)
}
