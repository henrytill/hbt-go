//go:build ignore

package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// TestCase represents a generated test case
type TestCase struct {
	Name       string
	InputFile  string
	OutputFile string
	Format     string
}

func main() {
	// go generate always runs from the package directory (integration/)
	testDataDir, err := filepath.Abs("../testdata")
	if err != nil {
		log.Fatalf("Failed to get testdata path: %v", err)
	}
	outputFile := "cli_test.go"

	// Find all test cases
	testCases, err := findTestCases(testDataDir)
	if err != nil {
		log.Fatalf("Error finding test cases: %v", err)
	}

	// Generate test file
	if err := generateTestFile(outputFile, testCases); err != nil {
		log.Fatalf("Error generating test file: %v", err)
	}

	fmt.Printf("Generated %d test cases in %s\n", len(testCases), outputFile)
}

func findTestCases(testDataDir string) ([]TestCase, error) {
	var testCases []TestCase

	// Map to track input files by their stem (name without .input.ext)
	inputFiles := make(map[string]string)
	expectedFiles := make(map[string]map[string]string) // stem -> format -> file

	err := filepath.WalkDir(testDataDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || d.Name() == "collection.schema.json" {
			return nil
		}

		fileName := d.Name()

		// Check for input files
		if stem, found := stripInputSuffix(fileName); found {
			inputFiles[stem] = path
		}

		// Check for expected output files
		if stem, format, found := stripExpectedSuffix(fileName); found {
			if expectedFiles[stem] == nil {
				expectedFiles[stem] = make(map[string]string)
			}
			expectedFiles[stem][format] = path
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	// Generate test cases by matching input and expected files
	for stem, inputPath := range inputFiles {
		if outputs, exists := expectedFiles[stem]; exists {
			for format, expectedPath := range outputs {
				// Create test name based on path and format
				category := filepath.Base(filepath.Dir(inputPath))
				testName := generateTestName(category, stem, format)

				testCases = append(testCases, TestCase{
					Name:       testName,
					InputFile:  inputPath,
					OutputFile: expectedPath,
					Format:     format,
				})
			}
		}
	}

	// Sort test cases by name for deterministic output
	sort.Slice(testCases, func(i, j int) bool {
		return testCases[i].Name < testCases[j].Name
	})

	return testCases, nil
}

// stripInputSuffix removes input suffixes and returns the stem
func stripInputSuffix(fileName string) (string, bool) {
	suffixes := []string{".input.html", ".input.md", ".input.json", ".input.xml"}
	for _, suffix := range suffixes {
		if strings.HasSuffix(fileName, suffix) {
			return strings.TrimSuffix(fileName, suffix), true
		}
	}
	return "", false
}

// stripExpectedSuffix removes expected suffixes and returns stem and format
func stripExpectedSuffix(fileName string) (string, string, bool) {
	suffixes := map[string]string{
		".expected.yaml": "yaml",
		".expected.html": "html",
	}

	for suffix, format := range suffixes {
		if strings.HasSuffix(fileName, suffix) {
			stem := strings.TrimSuffix(fileName, suffix)
			return stem, format, true
		}
	}
	return "", "", false
}

// generateTestName creates a valid Go test function name
func generateTestName(category, stem, format string) string {
	parts := []string{"Test"}
	caser := cases.Title(language.AmericanEnglish)

	// Add category if present
	if category != "" {
		parts = append(parts, titleCaseComponent(category, caser))
	}

	// Add stem components if present
	if stem != "" {
		stemParts := splitIntoAlphanumericParts(stem)
		for _, part := range stemParts {
			if part != "" {
				parts = append(parts, titleCaseComponent(part, caser))
			}
		}
	}

	// Add format with special handling for HTML
	parts = append(parts, formatTestSuffix(format, caser))

	return strings.Join(parts, "")
}

// splitIntoAlphanumericParts splits a string on non-alphanumeric characters
func splitIntoAlphanumericParts(s string) []string {
	return strings.FieldsFunc(s, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsDigit(r)
	})
}

// titleCaseComponent applies title casing to a component
func titleCaseComponent(s string, caser cases.Caser) string {
	return caser.String(s)
}

// formatTestSuffix returns the appropriate test suffix for a format
func formatTestSuffix(format string, caser cases.Caser) string {
	if format == "html" {
		return "Html" // Special case to match Go naming conventions
	}
	return caser.String(format)
}

func generateTestFile(outputFile string, testCases []TestCase) error {
	const testTemplate = `// Code generated by testgen

package integration

//go:generate go run testgen.go

import (
	"testing"
)
{{range .TestCases}}
func {{.Name}}(t *testing.T) {
	RunHbtAndCompare(t, {{printf "%q" .Format}}, {{printf "%q" .InputFile}}, {{printf "%q" .OutputFile}})
}
{{end}}
`

	templateData := struct {
		TestCases []TestCase
	}{
		TestCases: testCases,
	}

	// Parse and execute template
	tmpl, err := template.New("test").Parse(testTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse test template: %w", err)
	}

	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, templateData)
}
